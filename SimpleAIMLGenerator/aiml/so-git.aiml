<?xml version="1.0" ?>
<aiml version="1.0">
  <meta content="SimpleAIMLGenerator" name="author"/>
  <meta content="en" name="language"/>
  <category>
    <pattern>
      SOURC CONTROL OPTION
    </pattern>
    <template>
<![CDATA[<p>Mercurial runs very well under Windows--the major factor that encouraged us to adopt it where I work.  The best way to install and use it is <a href="http://tortoisehg.sourceforge.net/" rel="nofollow">TortoiseHg</a>, which provides integration with Explorer and open/save dialogs.  The package comes with the most recent command-line version of Mercurial, plus lots of bells and whistles, such as good GUI tools for viewing and searching your repository history, third-party extensions not normally included, and easy ways to configure your Mercurial setup.  If you interact often with Unix developers, you should also take a look at the <a href="http://www.selenic.com/mercurial/wiki/index.cgi/Win32Extension" rel="nofollow">win32text extension</a>, which will take care of line-ending issues.</p><br/><br/><p>As far as git on Windows goes: I don't personally find running a program in Cygwin on Windows counts as a native Windows solution, any more than running something compiled against winelib makes it a native Linux program.  You'll still have to deal with comparatively poor performance (git itself is fast, but makes many Unix-centric decisions that hurt it on Windows), an entirely different command-line set that won't integrate with the rest of your tool chain, and an entire new class of line-ending issues as some Unix-centric and some Windows-centric tools walk over your text files.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      GIT BETTER THAN SUBVERS
    </pattern>
    <template>
<![CDATA[<p>Git is not better than Subversion. But is also not worse. It's different.</p><br/><br/><p>The key difference is that it is decentralized. Imagine you are a developer on the road, you develop on your laptop and you want to have source control so that you can go back 3 hours.</p><br/><br/><p>With Subversion, you have a Problem: The SVN Repository may be in a location you can't reach (in your company, and you don't have internet at the moment), you cannot commit. If you want to make a copy of your code, you have to literally copy/paste it.</p><br/><br/><p>With Git, you do not have this problem. Your local copy is a repository, and you can commit to it and get all benefits of source control. When you regain connectivity to the main repository, you can commit against it.</p><br/><br/><p>This looks good at first, but just keep in mind the added complexity to this approach.</p><br/><br/><p>Git seems to be the "new, shiny, cool" thing. It's by no means bad (there is a reason Linus wrote it for the Linux Kernel development after all), but I feel that many people jump on the "Distributed Source Control" train just because it's new and is written by Linus Torvalds, without actually knowing why/if it's better.</p><br/><br/><p>Subversion has Problems, but so does Git, Mercurial, CVS, TFS or whatever.</p><br/><br/><p><strong>Edit:</strong> So this answer is now a year old and still generates many upvotes, so I thought I'll add some more explanations. In the last year since writing this, Git has gained a lot of momentum and support, particularly since sites like GitHub really took off. I'm using both Git and Subversion nowadays and I'd like to share some personal insight.</p><br/><br/><p>First of all, Git can be really confusing at first when working decentralized. What is a remote? and How to properly set up the initial repository? are two questions that come up at the beginning, especially compared to SVN's simple "svnadmin create", Git's "git init" can take the parameters --bare and --shared which seems to be the "proper" way to set up a centralized repository. There are reasons for this, but it adds complexity. The documentation of the "checkout" command is very confusing to people changing over - the "proper" way seems to be "git clone", while "git checkout" seems to switch branches.</p><br/><br/><p>Git REALLY shines when you are decentralized. I have a server at home and a Laptop on the road, and SVN simply doesn't work well here. With SVN, I can't have local source control if I'm not connected to the repository (Yes, I know about SVK or about ways to copy the repo). With Git, that's the default mode anyway. It's an extra command though (git commit commits locally, whereas git push origin master pushes the master branch to the remote named "origin").</p><br/><br/><p>As said above: Git adds complexity. Two modes of creating repositories, checkout vs. clone, commit vs. push... You have to know which commands work locally and which work with "the server" (I'm assuming most people still like a central "master-repository").</p><br/><br/><p>Also, the tooling is still insufficient, at least on Windows. Yes, there is a Visual Studio AddIn, but I still use git bash with msysgit.</p><br/><br/><p>SVN has the advantage that it's MUCH simpler to learn: There is your repository, all changes to towards it, if you know how to create, commit and checkout and you're ready to go and can pickup stuff like branching, update etc. later on.</p><br/><br/><p>Git has the advantage that it's MUCH better suited if some developers are not always connected to the master repository. Also, it's much faster than SVN. And from what I hear, branching and merging support is a lot better (which is to be expected, as these are the core reasons it was written).</p><br/><br/><p>This also explains why it gains so much buzz on the Internet, as Git is perfectly suited for Open Source projects: Just Fork it, commit your changes to your own Fork, and then ask the original project maintainer to pull your changes. With Git, this just works. Really, try it on Github, it's magic.</p><br/><br/><p>What I also see are Git-SVN Bridges: The central repository is a Subversion repo, but developers locally work with Git and the bridge then pushes their changes to SVN.</p><br/><br/><p>But even with this lengthy addition, I still stand by my core message: Git is not better or worse, it's just different. If you have the need for "Offline Source Control" and the willingness to spend some extra time learning it, it's fantastic. But if you have a strictly centralized Source Control and/or are struggling to introduce Source Control in the first place because your co-workers are not interested, then the simplicity and excellent tooling (at least on Windows) of SVN shine.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      VERSION CONTROL
    </pattern>
    <template>
<![CDATA[<p>The most important thing about version control is:</p><br/><br/><p><strong><em>JUST START USING IT</em></strong></p><br/><br/><p>Not using version control is a horrible idea. If you are not using version control, stop reading right now and start using it.</p><br/><br/><p>It is very easy to convert from</p><br/><br/><pre><code>cvs&lt;-&gt;svn&lt;-&gt;git&lt;-&gt;hg<br/></code></pre><br/><br/><p>It doesn't matter which one you choose. Just pick the easiest one for you to use and start recording the history of your code. You can always migrate to another (D)VCS later.</p><br/><br/><p>If you are looking for a easy to use GUI look at TortoiseSVN (Windows) and <a href="http://www.versionsapp.com/" rel="nofollow">Versions (Mac)</a> (Suggested by <a href="http://stackoverflow.com/questions/2658?sort=newest#2708" rel="nofollow">codingwithoutcomments</a>)</p><br/><br/><p><hr /></p><br/><br/><p>Edit:</p><br/><br/><blockquote><br/>  <p><a href="http://stackoverflow.com/questions/2658/#2672" rel="nofollow">pix0r said:</a></p><br/>  <br/>  <p>Git has some nice features, but you won't be able to appreciate them unless you've already used something more standard like CVS or Subversion.</p><br/></blockquote><br/><br/><p>This. Using git is pointless if you don't know what version control can do for you.</p><br/><br/><p>Edit 2:</p><br/><br/><p>Just saw this link on reddit: <a href="http://www.addedbytes.com/cheat-sheets/subversion-cheat-sheet/" rel="nofollow">Subversion Cheat Sheet</a>. Good quick reference for the svn command line.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      A GIT RESET HARD HEAD 1
    </pattern>
    <template>
<![CDATA[<p>Pat Notz is correct.  You can get the commit back so long as it's been within a few days.  git only garbage collects after about a month or so unless you explicitly tell it to remove newer blobs.</p><br/><br/><pre><code>$ git init<br/>Initialized empty Git repository in .git/<br/><br/>$ echo "testing reset" &gt; file1<br/>$ git add file1<br/>$ git commit -m 'added file1'<br/>Created initial commit 1a75c1d: added file1<br/> 1 files changed, 1 insertions(+), 0 deletions(-)<br/> create mode 100644 file1<br/><br/>$ echo "added new file" &gt; file2<br/>$ git add file2<br/>$ git commit -m 'added file2'<br/>Created commit f6e5064: added file2<br/> 1 files changed, 1 insertions(+), 0 deletions(-)<br/> create mode 100644 file2<br/><br/>$ git reset --hard HEAD^<br/>HEAD is now at 1a75c1d... added file1<br/><br/>$ cat file2<br/>cat: file2: No such file or directory<br/><br/>$ git reflog<br/>1a75c1d... HEAD@{0}: reset --hard HEAD^: updating HEAD<br/>f6e5064... HEAD@{1}: commit: added file2<br/><br/>$ git reset --hard f6e5064<br/>HEAD is now at f6e5064... added file2<br/><br/>$ cat file2<br/>added new file<br/></code></pre><br/><br/><p>You can see in the example that the file2 was removed as a result of the hard reset, but was put back in place when I reset via the reflog.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      UP AN EDITOR TO WORK WITH GIT ON WINDOW
    </pattern>
    <template>
<![CDATA[<p>I just tested it with git version 1.6.2.msysgit.0.186.gf7512 and Notepad++5.3.1</p><br/><br/><p>I prefer to <em>not</em> have to set an EDITOR variable, so I tried:</p><br/><br/><pre><code>git config --global core.editor "\"c:\Program Files\Notepad++\notepad++.exe\""<br/>or<br/>git config --global core.editor "\"c:\Program Files\Notepad++\notepad++.exe\" %*"<br/></code></pre><br/><br/><p>That always give:</p><br/><br/><pre><code>C:\prog\git&gt;git config --global --edit<br/>"c:\Program Files\Notepad++\notepad++.exe" %*: c:\Program Files\Notepad++\notepad++.exe: command not found<br/>error: There was a problem with the editor '"c:\Program Files\Notepad++\notepad++.exe" %*'.<br/></code></pre><br/><br/><p>If I define a npp.bat including:</p><br/><br/><pre><code>"c:\Program Files\Notepad++\notepad++.exe" %*<br/></code></pre><br/><br/><p>and I type:</p><br/><br/><pre><code>C:\prog\git&gt;git config --global core.editor C:\prog\git\npp.bat<br/></code></pre><br/><br/><p>It just works from the DOS session, <strong>but not from the git shell</strong>.<br><br/>(not that with the core.editor configuration mechanism, a script with "<code>start /WAIT...</code>" in it would not work, but only open a new DOS window)</p><br/><br/><hr><br/><br/><p><a href="http://stackoverflow.com/questions/10564/how-can-i-set-up-an-editor-to-work-with-git-on-windows/1431003#1431003">Bennett's answer</a> mentions the possibility to avoid adding a script, but to reference directly the program itself <strong>between simple quotes</strong>:</p><br/><br/><pre><code>git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"<br/></code></pre><br/><br/><p>But I prefer using a script (see below): that way I can play with different paths or different options without having to register again a <code>git config</code>.</p><br/><br/><hr><br/><br/><p>The actual solution (with a script) was to realize that:<br><br/><strong>what you refer to in the config file is actually a shell (<code>/bin/sh</code>) script</strong>, not a DOS script.</p><br/><br/><p>So what does work is:</p><br/><br/><pre><code>C:\prog\git&gt;git config --global core.editor C:/prog/git/npp.bat<br/></code></pre><br/><br/><p>with <code>C:/prog/git/npp.bat</code>:</p><br/><br/><pre><code>#!/bin/sh<br/>"c:/Program Files/Notepad++/notepad++.exe" -multiInst "$*"<br/></code></pre><br/><br/><p>or</p><br/><br/><pre><code>#!/bin/sh<br/>"c:/Program Files/Notepad++/notepad++.exe" -multiInst -notabbar -nosession -noPlugin "$*"<br/></code></pre><br/><br/><p>With that setting, I can do '<code>git config --global --edit</code>' from DOS or Git Shell, or I can do '<code>git rebase -i ...</code>' from DOS or Git Shell.<br><br/>Bot commands will trigger a new instance of notepad++ (hence the <code>-multiInst</code>' option), and wait for that instance to be closed before going on.</p><br/><br/><p>Note that I use only '/', not <code>\</code>'. And I <a href="http://stackoverflow.com/questions/623518/msysgit-on-windows-what-should-i-be-aware-of-if-any">installed msysgit using option 2.</a> (Add the <code>git\bin</code> directory to the <code>PATH</code> environment variable, but without overriding some built-in windows tools)</p><br/><br/><p>The fact that the notepad++ wrapper is called .bat is not important.<br><br/>It would be better to name it 'npp.sh' and to put it in the <code>[git]\cmd</code> directory though (or in any directory referenced by your PATH environment variable).</p><br/><br/><hr><br/><br/><p>See also:</p><br/><br/><ul><br/><li><a href="http://stackoverflow.com/questions/255202/how-do-i-view-git-diff-output-with-visual-diff-program/255212#255212">How do I view 'git diff' output with visual diff program?</a> for the general theory</li><br/><li><a href="http://stackoverflow.com/questions/780425/how-do-i-setup-diffmerge-with-msysgit-gitk/783667#783667">How do I setup DiffMerge with msysgit / gitk?</a> for another example of external tool (DiffMerge, and WinMerge)</li><br/></ul><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      TO GIT
    </pattern>
    <template>
<![CDATA[<p>I think that the most important thing to understand about Git is the <a href="http://codemac.net/blog/18/" rel="nofollow">index</a> (especially when used with <code>add -i</code>). I also found this <a href="http://osteele.com/archives/2008/05/my-git-workflow" rel="nofollow">page</a> to be very helpful in understanding the importance of using the index and how it can allow for a very dynamic workflow.</p><br/><br/><p>Of course, there is also the <a href="http://git.or.cz/course/svn.html" rel="nofollow">Git SVN crash course</a> (as mentioned by mk) and the <a href="http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html" rel="nofollow">Git Tutorial</a> for some more general info.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      BRANCH NAME IN GIT
    </pattern>
    <template>
<![CDATA[<p>In addition to the other comments, you may find the -m (move) switch to git-branch helpful. You could rename your old master to something else, then rename your new branch to master:</p><br/><br/><pre><code>git branch -m master crap_work<br/>git branch -m previous_master master<br/></code></pre><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      GRAPH THE LINE OF CODE HISTORI FOR GIT REPO
    </pattern>
    <template>
<![CDATA[<p>You might also consider <a href="http://gitstats.sourceforge.net/" rel="nofollow">gitstats</a>, which generates this graph as an html file.  </p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      UNVERS A FILE IN EITHER SVN AND OR GIT
    </pattern>
    <template>
<![CDATA[<p>SVN version 1.5 supports removing/deleting a file from a repository with out losing the local file</p><br/><br/><p>taken from <a href="http://subversion.tigris.org/svn_1.5_releasenotes.html" rel="nofollow">http://subversion.tigris.org/svn_1.5_releasenotes.html</a> </p><br/><br/><p>New --keep-local option retains path after delete..</p><br/><br/><p>Delete (remove) now takes a --keep-local option to retain its targets locally, so paths will not be removed even if unmodified.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      A GIT SUBDIRECTORI IN CAPISTRANO
    </pattern>
    <template>
<![CDATA[<p>You can have two git repositories (client and server) and add them to a "super-project" (app). In this "super-project" you can add the two repositories as submodules (check <a href="https://git.wiki.kernel.org/articles/g/i/t/GitSubmoduleTutorial_c489.html" rel="nofollow">this tutorial</a>).</p><br/><br/><p>Another possible solution (a bit more dirty) is to have separate branches for client and server, and then you can pull from the 'server' branch.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      GIT REPOSITORI VIEWER FOR MAC
    </pattern>
    <template>
<![CDATA[<p>There's also <a href="http://www.gitx.org" rel="nofollow">gitx</a>, it's progressing well and under active development (multiple commits per day).</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      RESTOR FILE TO PREVIOU STATE IN GIT
    </pattern>
    <template>
<![CDATA[<pre><code>git checkout foo<br/></code></pre><br/><br/><p>That will reset <code>foo</code> to HEAD. You can also:</p><br/><br/><pre><code>git checkout HEAD^ foo<br/></code></pre><br/><br/><p>for one revision back, etc.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      MERCURI AND GIT
    </pattern>
    <template>
<![CDATA[<p>These articles may help:</p><br/><br/><ul><br/><li><a href="http://importantshock.wordpress.com/2008/08/07/git-vs-mercurial/">Git vs. Mercurial: Please Relax</a> (Git is MacGyver and Mercurial is James Bond)</li><br/><li><a href="http://www.rockstarprogrammer.org/post/2008/apr/06/differences-between-mercurial-and-git/">The Differences Between Mercurial and Git</a></li><br/></ul><br/><br/><p><strong>Edit</strong>: Comparing Git and Mercurial to celebrities seems to be a trend. Here's one more:</p><br/><br/><ul><br/><li><a href="http://www.ericsink.com/entries/hg_denzel.html">Git is Wesley Snipes, Mercurial is Denzel Washington</a></li><br/></ul><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      ORGANIS MULTIPL GIT REPOSITORI
    </pattern>
    <template>
<![CDATA[<p>I would <strong>strongly</strong> advise against putting unrelated data in a given<br/>Git repository.  The overhead of creating new repositories is quite<br/>low, and that is a <em>feature</em> that makes it possible to keep<br/>different lineages completely separate.</p><br/><br/><p>Fighting that idea means ending up with unnecessarily tangled history,<br/>which renders administration more difficult and--more<br/>importantly--"archeology" tools less useful because of the resulting<br/>dilution.  Also, as you mentioned, Git assumes that the "unit of<br/>cloning" is the repository, and practically has to do so because of<br/>its distributed nature.</p><br/><br/><p>One solution is to keep every project/package/etc. as its own <em>bare</em><br/>repository (i.e., without working tree) under a blessed hierarchy,<br/>like:</p><br/><br/><pre><code>/repos/a.git<br/>/repos/b.git<br/>/repos/c.git<br/></code></pre><br/><br/><p>Once a few conventions have been established, it becomes trivial to<br/>apply administrative operations (backup, packing, web publishing) to<br/>the complete hierarchy, which serves a role not entirely dissimilar to<br/>"monolithic" SVN repositories.  Working with these repositories also<br/>becomes somewhat similar to SVN workflows, with the addition that one<br/><em>can</em> use local commits and branches:</p><br/><br/><pre><code>svn checkout   --&gt; git clone<br/>svn update     --&gt; git pull<br/>svn commit     --&gt; git push<br/></code></pre><br/><br/><p>You can have multiple remotes in each working clone, for the ease of<br/>synchronizing between the multiple parties:</p><br/><br/><pre><code>$ cd ~/dev<br/>$ git clone /repos/foo.git       # or the one from github, ...<br/>$ cd foo<br/>$ git remote add github ...<br/>$ git remote add memorystick ...<br/></code></pre><br/><br/><p>You can then fetch/pull from each of the "sources", work and commit<br/>locally, and then push ("backup") to each of these remotes when you<br/>are ready with something like (note how that pushes the <em>same</em> commits<br/>and history to each of the remotes!):</p><br/><br/><pre><code>$ for remote in origin github memorystick; do git push $remote; done<br/></code></pre><br/><br/><p>The easiest way to turn an existing working repository <code>~/dev/foo</code><br/>into such a bare repository is probably:</p><br/><br/><pre><code>$ cd ~/dev<br/>$ git clone --bare foo /repos/foo.git<br/>$ mv foo foo.old<br/>$ git clone /repos/foo.git<br/></code></pre><br/><br/><p>which is mostly equivalent to a <code>svn import</code>--but does not throw the<br/>existing, "local" history away.</p><br/><br/><p>Note: <em>submodules</em> are a mechanism to include shared <em>related</em><br/>lineages, so I indeed wouldn't consider them an appropriate tool for<br/>the problem you are trying to solve.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      REMOV A SPECIF REVIS IN THE GIT HISTORI
    </pattern>
    <template>
<![CDATA[<p>To combine revision 3 and 4 into a single revision, you can use git rebase. If you want to remove the changes in revision 3, you need to use the edit command in the interactive rebase mode. If you want to combine the changes into a single revision, use squash.</p><br/><br/><p>I have successfully used this squash technique, but have never needed to remove a revision before. The git-rebase documentation under "Splitting commits" should hopefully give you enough of an idea to figure it out. (Or someone else might know).</p><br/><br/><p>From the <a href="http://www.kernel.org/pub/software/scm/git/docs/git-rebase.html" rel="nofollow">git documentation</a>:</p><br/><br/><blockquote><br/><p>Start it with the last commit you want to retain as-is:</p><br/><br/><blockquote><code>git rebase -i &lt;after-this-commit&gt;</code></blockquote><br/><br/><p>An editor will be fired up with all the commits in your current branch (ignoring merge commits), which come after the given commit. You can reorder the commits in this list to your heart's content, and you can remove them. The list looks more or less like this:</p><br/><br/><blockquote><pre>pick deadbee The oneline of this commit<br/>pick fa1afe1 The oneline of the next commit<br/>...</pre></blockquote><br/><br/><p>The oneline descriptions are purely for your pleasure; git-rebase will not look at them but at the commit names ("deadbee" and "fa1afe1" in this example), so do not delete or edit the names.</p><br/><br/><p>By replacing the command "pick" with the command "edit", you can tell git-rebase to stop after applying that commit, so that you can edit the files and/or the commit message, amend the commit, and continue rebasing.</p><br/><br/><p>If you want to fold two or more commits into one, replace the command "pick" with "squash" for the second and subsequent commit. If the commits had different authors, it will attribute the squashed commit to the author of the first commit.</p><br/></blockquote><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      GITHUB + FOGBUGZ OR ASSEMBLA
    </pattern>
    <template>
<![CDATA[<p>The last time I used Trac (about a year ago), it really couldn't compete with FogBugz. FogBugz makes tracking the time you spend on different tasks (or cases, whatever) easy, and then uses that info to produce great reports. I can't rave enough about evidence-based scheduling. Trac was more of an "It's nice because it's free" experience for me.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      BAD SHA1 FILE ERROR
    </pattern>
    <template>
<![CDATA[<p>It's not a simple answer, sadly. But this might help:</p><br/><br/><p><a href="http://schacon.github.com/git/user-manual.html#recovering-from-repository-corruption" rel="nofollow">Recovering from repository corruption</a> (from the Git's user manual).</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      STASH VS. GIT BRANCH
    </pattern>
    <template>
<![CDATA[<p>'stash' takes the uncommitted, "<em>dirty</em>" stuff on your working copy, and stashes it away, leaving you with a clean working copy.</p><br/><br/><p>It doesn't really branch at all. You can then apply the stash on top of any other branch. Or, as of Git 1.6, you can do:</p><br/><br/><pre><code>git stash branch &lt;branchname&gt; [&lt;stash&gt;]<br/></code></pre><br/><br/><p>to apply the stash on top of a new branch, all in one command.</p><br/><br/><p>So, stash works great if you have not committed to the "<em>wrong</em>" branch yet.</p><br/><br/><p>If you've already committed, then the workflow you describe in your question is a better alternative. And by the way, you're right: Git is very flexible, and with that flexibility comes overlapping functionality.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      GIT HAVE ANYTH LIKE SVN PROPSET SVN KEYWORD OR PRE POST COMMIT HOOK
    </pattern>
    <template>
<![CDATA[<p>Quoting from the <a href="http://git.or.cz/gitwiki/GitFaq" rel="nofollow">Git FAQ</a>:</p><br/><br/><blockquote><br/>  <p>Does git have keyword expansion?</p><br/>  <br/>  <p>Not recommended. Keyword expansion causes all sorts of strange problems and<br/>  isn't really useful anyway, especially within the context of an SCM. Outside<br/>  git you may perform keyword expansion using a script. The Linux kernel export<br/>  script does this to set the EXTRA_VERSION variable in the Makefile.</p><br/>  <br/>  <p>See gitattributes(5) if you really want to do this. If your translation is not<br/>  reversible (eg SCCS keyword expansion) this may be problematic.</p><br/></blockquote><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      BUG TRACKER SETUP WITH GIT INTEGR
    </pattern>
    <template>
<![CDATA[<p><a href="http://www.redmine.org/" rel="nofollow">Redmine</a> can do some of what you're asking for.  Integration works in one direction, you must <a href="http://www.redmine.org/projects/redmine/wiki/RedmineSettings#Referencing-issues-in-commit-messages" rel="nofollow">reference issues in commit messages</a>, and then this data will be available in redmine.  </p><br/><br/><p>The data is then available in two views.  The bug display will include a list of matched commits.  The repository display will link commits to bug display pages.</p><br/><br/><p>Redmine keeps a local (bare) repository for each project.  This can be the primary repo or a remote mirror.  On updates, redmine parses the commit messages and updates an internal cross reference table of change_set,issue.  </p><br/><br/><p>If the redmine repository is only used as a mirror, it will need to be updated.  Updates can happen via cron or via external hook.  We use a <a href="http://mentalized.net/journal/2009/08/03/redmine_plugin_github_hook/" rel="nofollow">redmine github plugin</a> and a github post-receive hook to keep redmine in sync with a primary github repository.</p><br/><br/><p>It works, but it is still a bit clumsy.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      OF WRITE A GIT PRE COMMIT HOOK TO CHECK ANI PHP FILE IN A COMMIT FOR PARS ERROR
    </pattern>
    <template>
<![CDATA[<p>If the commit is a partial commit (not all the changes in the working tree are committed), then this make give incorrect results since it tests the working copy and not the staged copy.</p><br/><br/><p>One way to do this could be:</p><br/><br/><pre><code>git diff --cached --name-only --diff-filter=ACMR | xargs git checkout-index --prefix=$TMPDIR/ --<br/>find $TMPDIR -name '*.php' -print | xargs -n 1 php -l<br/></code></pre><br/><br/><p>Which would make a copy of the staged images into a scratch space and then run the test command on them there. If any of the files include other files in the build then you may have to recreate the whole staged image in the test tree and then test the changed files there (See: <a href="http://stackoverflow.com/questions/2412450/git-pre-commit-hook-changed-added-files/3068990#3068990">Git pre-commit hook : changed/added files</a>).</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      BRANCH AND MERG EASIER IN MERCURI THAN IN SUBVERS
    </pattern>
    <template>
<![CDATA[<blockquote><br/>  <p>In Subversion (and CVS), the repository is first and foremost. In git<br/>  and mercurial there is not really the concept of a repository in the<br/>  same way; here changes are the central theme.</p><br/></blockquote><br/><br/><p>+1</p><br/><br/><p>The hassle in CVS/SVN comes from the fact that these systems do <strong>not</strong><br/>remember the parenthood of changes.  In Git and Mercurial,<br/>not only can a commit have multiple children, it can also have multiple<br/>parents!</p><br/><br/><p>That can easily observed using one of the graphical tools, <code>gitk</code> or <code>hg<br/>view</code>.  In the following example, branch #2 was forked from #1 at<br/>commit A, and has since been merged once (at M, merged with commit B):</p><br/><br/><pre><code>o---A---o---B---o---C         (branch #1)<br/>     \       \<br/>      o---o---M---X---?       (branch #2)<br/></code></pre><br/><br/><p>Note how A and B have two children, whereas M has two <strong>parents</strong>.  These<br/>relationships are <em>recorded</em> in the repository.  Let's say the maintainer of<br/>branch #2 now wants to merge the latest changes from branch #1, they can<br/>issue a command such as:</p><br/><br/><pre><code>$ git merge branch-1<br/></code></pre><br/><br/><p>and the tool will automatically know that the <em>base</em> is B--because it<br/>was recorded in commit M, an ancestor of the tip of #2--and<br/>that it has to merge whatever happened<br/>between B and C.  CVS does not record this information, nor did SVN prior to<br/>version 1.5.  In these systems, the graph<br/>would look like:</p><br/><br/><pre><code>o---A---o---B---o---C         (branch #1)<br/>     \    <br/>      o---o---M---X---?       (branch #2)<br/></code></pre><br/><br/><p>where M is just a gigantic "squashed" commit of everything that happened between A and B,<br/>applied on top of M.  Note that after the deed is done, there is <em>no trace<br/>left</em> (except potentially in human-readable comments) of where M did<br/>originate from, nor of <em>how many</em> commits were collapsed together--making<br/>history much more impenetrable.</p><br/><br/><p>Worse still, performing a second merge becomes a nightmare: one has to figure out<br/>what the merge base was at the time of the first merge (and one <em>has</em> to <em>know</em><br/>that there has been a merge in the first place!), then<br/>present that information to the tool so that it does not try to replay A..B on<br/>top of M.  All of this is difficult enough when working in close collaboration, but is<br/>simply impossible in a distributed environment.</p><br/><br/><p>A (related) problem is that there is no way to answer the question: "does X<br/>contain B?" where B is a<br/>potentially important bug fix.  So, why not just record that information in the commit, since<br/>it is <em>known</em> at merge time!</p><br/><br/><p>P.-S. -- I have no experience with SVN 1.5+ merge recording abilities, but the workflow seems to be much more<br/>contrived than in the distributed systems.  If that is indeed the case, it's probably because--as mentioned<br/>in the above comment--the focus is put on repository organization rather than on the changes themselves.</p><br/>]]>    </template>
  </category>
</aiml>
