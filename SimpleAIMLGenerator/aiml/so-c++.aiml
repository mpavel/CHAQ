<?xml version="1.0" ?>
<aiml version="1.0">
  <meta content="SimpleAIMLGenerator" name="author"/>
  <meta content="en" name="language"/>
  <category>
    <pattern>
      C SOCKET API IN C + + ON Z O
    </pattern>
    <template>
<![CDATA[<p>Keep a copy of the IBM manuals handy:</p><br/><br/><p><a href="http://publibz.boulder.ibm.com/cgi-bin/bookmgr%5FOS390/BOOKS/EDCLB1A0/CCONTENTS?DT=20090607203246"> z/OS V1R11.0 XL C/C++ Run-Time Library Reference</a><br/><a href="http://publibz.boulder.ibm.com/cgi-bin/bookmgr%5FOS390/BOOKS/CBCPG1A0/CCONTENTS?DT=20090606065305"> z/OS V1R11.0 XL C/C++ Programming Guide</a></p><br/><br/><p>The IBM publications are generally very good, but you need to get used to their format, as well as knowing where to look for an answer.  You'll find quite often that a feature that you want to use is guarded by a "feature test macro"</p><br/><br/><p>You should ask your friendly system programmer to install the <a href="http://www-03.ibm.com/servers/eserver/zseries/zos/le/manpgs.html">XL C/C++ Run-Time Library Reference: Man Pages<br/></a> on your system.  Then you can do things like "man connect" to pull up the man page for the socket connect() API.  When I do that, this is what I see:</p><br/><br/><p>FORMAT</p><br/><br/><p>X/Open</p><br/><br/><pre><code>#define _XOPEN_SOURCE_EXTENDED 1<br/>#include &lt;sys/socket.h&gt;<br/><br/>int connect(int socket, const struct sockaddr *address, socklen_t address_len);<br/></code></pre><br/><br/><p>Berkeley Sockets</p><br/><br/><pre><code>#define _OE_SOCKETS<br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/socket.h&gt;<br/><br/>int connect(int socket, struct sockaddr *address, int address_len);<br/></code></pre><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      GETTIMEOFDAY ( ) GUARANTE TO BE OF MICROSECOND RESOLUT
    </pattern>
    <template>
<![CDATA[<p>Maybe. But you have bigger problems. <code>gettimeofday()</code> can result in incorrect timings if there are processes on your system that change the timer (ie, ntpd). On a "normal" linux, though, I believe the resolution of <code>gettimeofday()</code> is 10us. It can jump forward and backward and time, consequently, based on the processes running on your system. This effectively makes the answer to your question no.</p><br/><br/><p>You should look into <code>clock_gettime(CLOCK_MONOTONIC)</code> for timing intervals. It suffers from several less issues due to things like multi-core systems and external clock settings.</p><br/><br/><p>Also, look into the clock_getres() function.</p>]]>    </template>
  </category>
  <category>
    <pattern>
      GTK IMPLEMENT OF MESSAGEBOX
    </pattern>
    <template>
<![CDATA[<p>Hmm, ok.  I'd suggest code like this, then:</p><br/><br/><pre><code>typedef struct {<br>    int type;<br>    int result;<br>} DialogData;<br><br>static gboolean<br>display_dialog(gpointer user_data)<br>{<br>    DialogData *dialog_data = user_data;<br>    GtkWidget *dialog;<br><br>    if (dialog_data-&gt;type &amp; MB_YESNO)<br>        dialog = gtk_message_dialog_new(...);<br>    else<br>        dialog = gtk_message_dialog_new(...);<br><br>    // Set title, etc.<br><br>    dialog_data-&gt;result = gtk_dialog_run(...);<br><br>    gtk_main_quit();  // Quits the main loop run in MessageBox()<br><br>    return FALSE;<br>}<br><br>int MessageBox(...)<br>{<br>    DialogData dialog_data;<br><br>    dialog_data.type = type;<br><br>    gtk_idle_add(display_dialog, &amp;dialog_data);<br><br>    gtk_main();<br><br>    // Do stuff based on dialog_data.result<br>}<br></code></pre><br/><br/><p>The struct is because you need to pass around a couple pieces of data.  The <code>gtk_idle_add()</code> call adds a method to be run when the main loop is running and idle, and the <code>FALSE</code> return value from the <code>display_dialog()</code> call means that it's only run once.  After we get the result from the dialog, we quit the main loop.  That'll cause the <code>gtk_main()</code> in your main <code>MessageBox()</code> method to return, and you'll be able to access the result from there.</p><br/><br/><p>Hope this helps!</p>]]>    </template>
  </category>
  <category>
    <pattern>
      IDE FOR LINUX
    </pattern>
    <template>
<![CDATA[<p><a href="http://projects.gnome.org/gedit/" rel="nofollow">gedit</a></p><br/><br/><ul><br/><li>Syntax highlighting</li><br/><li>Fast, lightweight</li><br/><li>Tabs</li><br/><li>GUI</li><br/></ul><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      CONFIGUR AND COMMUN WITH A SERIAL PORT
    </pattern>
    <template>
<![CDATA[<p>Build a time machine and go back to 1987? Ho ho.</p><br/><br/><p>Ok, no more snarky comments.</p><br/><br/><blockquote><br/>  <p>How do I figure out what the configuration settings (e.g. baud rate) should be...</p><br/></blockquote><br/><br/><p>Read the datasheet? Ok, ok. Seriously, last one. If you don't know the baud rate of the device you are trying to communicate with, you have two choices. Start guessing, or possibly bust out an o-scope. If you need a good starting point, let me suggest 9600-8-N-1. My suspicion is you can get there with brute force relatively quickly. There's a third option of having an old-school ninja who can tell just by the LOOK of the garbled characters at some standard baud rate what actual baud rate is. An impressive party trick to be sure.</p><br/><br/><p>Hopefully though you have access to this information. In unix/linux, you can get ahold of minicom to play with the serial port directly. This should make it fairly quick to get the configuration figured out.</p><br/><br/><blockquote><br/>  <p>one of the major Unix shells</p><br/></blockquote><br/><br/><p>In Unix the serial port(s) is/are file-mapped into the /dev/ subdir. ttyS0, for example. If you setup the correct baud rate and whatnot using minicom, you can even cat stuff to that file to send stuff out there.</p><br/><br/><p>On to the meat of the question, you can access it programmatically through the POSIX headers. termios.h is the big one. </p><br/><br/><p>See: <a href="http://www.easysw.com/%7Emike/serial/serial.html#3_1" rel="nofollow">http://www.easysw.com/~mike/serial/serial.html#3_1</a></p><br/><br/><blockquote><br/>  <p>but I also have some interest in serial programming using Windows/Hyperterminal.</p><br/></blockquote><br/><br/><p>Hyperterminal and minicom are basically the same program. As for how Windows let's you get access to the serial port, I'll leave that question for someone else. I haven't done that in Windows since the Win95 days.</p>]]>    </template>
  </category>
  <category>
    <pattern>
      C + + LIBRARI FOR READ MIDI SIGNAL FROM A USB MIDI DEVIC
    </pattern>
    <template>
<![CDATA[<p><a href="http://portmedia.sourceforge.net/portmidi/" rel="nofollow">PortMidi</a> is another open source cross-platform MIDI I/O library worth checking out.  On the other hand, if you are working on a sysex type of app, then direct Win32 works easily enough.</p><br/><br/><p>Just came across another open source cross-platform framework that includes MIDI support: <a href="http://www.rawmaterialsoftware.com/juce/" rel="nofollow">Juce</a>.</p><br/><br/><p>Also, I should note that there isn't anything special about a USB connected MIDI device.  It will still be presented as a MIDI device in Windows and you will use standard MIDI APIs (mmsystem) to communicate with it.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      BARRIER TO UNDERSTAND POINTER AND WHAT CAN BE DONE TO OVERCOM THEM
    </pattern>
    <template>
<![CDATA[<p>Pointers is a concept that for many can be confusing at first, in particular when it comes to copying pointer values around and still referencing the same memory block.</p><br/><br/><p>I've found that the best analogy is to consider the pointer as a piece of paper with a house address on it, and the memory block it references as the actual house. All sorts of operations can thus be easily explained.</p><br/><br/><p>I've added some Delphi code down below, and some comments where appropriate. I chose Delphi since my other main programming language, C#, does not exhibit things like memory leaks in the same way.</p><br/><br/><p>If you only wish to learn the high-level concept of pointers, then you should ignore the parts labelled "Memory layout" in the explanation below. They are intended to give examples of what memory could look like after operations, but they are more low-level in nature. However, in order to accurately explain how buffer overruns really work, it was important that I added these diagrams.</p><br/><br/><p><em>Disclaimer: For all intents and purposes, this explanation and the example memory<br/>layouts are vastly simplified. There's more overhead and a lot more details you would<br/>need to know if you need to deal with memory on a low-level basis. However, for the<br/>intents of explaining memory and pointers, it is accurate enough.</em></p><br/><br/><hr><br/><br/><p>Let's assume the THouse class used below looks like this:</p><br/><br/><pre><code>type<br/>    THouse = class<br/>    private<br/>        FName : array[0..9] of Char;<br/>    public<br/>        constructor Create(name: PChar);<br/>    end;<br/></code></pre><br/><br/><p>When you initialize the house object, the name given to the constructor is copied into the private field FName. There is a reason it is defined as a fixed-size array.</p><br/><br/><p>In memory, there will be some overhead associated with the house allocation, I'll illustrate this below like this:</p><br/><br/><pre><br/>---[ttttNNNNNNNNNN]---<br/>     ^   ^<br/>     |   |<br/>     |   +- the FName array<br/>     |<br/>     +- overhead<br/></pre><br/><br/><p>The "tttt" area is overhead, there will typically be more of this for various types of runtimes and languages, like 8 or 12 bytes. It is imperative that whatever values are stored in this area never gets changed by anything other than the memory allocator or the core system routines, or you risk crashing the program.</p><br/><br/><hr><br/><br/><p><strong>Allocate memory</strong></p><br/><br/><p>Get an entrepreneur to build your house, and give you the address to the house. In contrast to the real world, memory allocation cannot be told where to allocate, but will find a suitable spot with enough room, and report back the address to the allocated memory.</p><br/><br/><p>In other words, the entrepreneur will choose the spot.</p><br/><br/><pre><code>THouse.Create('My house');<br/></code></pre><br/><br/><p>Memory layout:</p><br/><br/><pre><br/>---[ttttNNNNNNNNNN]---<br/>    1234My house<br/></pre><br/><br/><hr><br/><br/><p><strong>Keep a variable with the address</strong></p><br/><br/><p>Write the address to your new house down on a piece of paper. This paper will serve as your reference to your house. Without this piece of paper, you're lost, and cannot find the house, unless you're already in it.</p><br/><br/><pre><code>var<br/>    h: THouse;<br/>begin<br/>    h := THouse.Create('My house');<br/>    ...<br/></code></pre><br/><br/><p>Memory layout:</p><br/><br/><pre><br/>    h<br/>    v<br/>---[ttttNNNNNNNNNN]---<br/>    1234My house<br/></pre><br/><br/><hr><br/><br/><p><strong>Copy pointer value</strong>  </p><br/><br/><p>Just write the address on a new piece of paper. You now have two pieces of paper that will get you to the same house, not two separate houses. Any attempts to follow the address from one paper and rearrange the furniture at that house will make it seem that <em>the other house</em> has been modified in the same manner, unless you can explicitly detect that it's actually just one house.</p><br/><br/><p><em>Note</em> This is usually the concept that I have the most problem explaining to people, two pointers does not mean two objects or memory blocks.</p><br/><br/><pre><code>var<br/>    h1, h2: THouse;<br/>begin<br/>    h1 := THouse.Create('My house');<br/>    h2 := h1; // copies the address, not the house<br/>    ...<br/></code></pre><br/><br/><pre><br/>    h1<br/>    v<br/>---[ttttNNNNNNNNNN]---<br/>    1234My house<br/>    ^<br/>    h2<br/></pre><br/><br/><hr><br/><br/><p><strong>Freeing the memory</strong>  </p><br/><br/><p>Demolish the house. You can then later on reuse the paper for a new address if you so wish, or clear it to forget the address to the house that no longer exists.</p><br/><br/><pre><code>var<br/>    h: THouse;<br/>begin<br/>    h := THouse.Create('My house');<br/>    ...<br/>    h.Free;<br/>    h := nil;<br/></code></pre><br/><br/><p>Here I first construct the house, and get hold of its address. Then I do something to the house (use it, the ... code, left as an exercise for the reader), and then I free it. Lastly I clear the address from my variable.</p><br/><br/><p>Memory layout:</p><br/><br/><pre><br/>    h                        &lt;--+<br/>    v                           +- before free<br/>---[ttttNNNNNNNNNN]---          |<br/>    1234My house             &lt;--+<br/><br/>    h (now points nowhere)   &lt;--+<br/>                                +- after free<br/>----------------------          | (note, memory might still<br/>    xx34My house             &lt;--+  contain some data)<br/></pre><br/><br/><hr><br/><br/><p><strong>Dangling pointers</strong></p><br/><br/><p>You tell your entrepreneur to destroy the house, but you forget to erase the address from your piece of paper. When later on you look at the piece of paper, you've forgotten that the house is no longer there, and goes to visit it, with failed results (see also the part about an invalid reference below).</p><br/><br/><pre><code>var<br/>    h: THouse;<br/>begin<br/>    h := THouse.Create('My house');<br/>    ...<br/>    h.Free;<br/>    ... // forgot to clear h here<br/>    h.OpenFrontDoor; // will most likely fail<br/></code></pre><br/><br/><p>Using <code>h</code> after the call to <code>.Free</code> <em>might</em> work, but that is just pure luck. Most likely it will fail, at a customers place, in the middle of a critical operation.</p><br/><br/><pre><br/>    h                        &lt;--+<br/>    v                           +- before free<br/>---[ttttNNNNNNNNNN]---          |<br/>    1234My house             &lt;--+<br/><br/>    h                        &lt;--+<br/>    v                           +- after free<br/>----------------------          |<br/>    xx34My house             &lt;--+<br/></pre><br/><br/><p>As you can see, h still points to the remnants of the data in memory, but<br/>since it might not be complete, using it as before might fail.</p><br/><br/><hr><br/><br/><p><strong>Memory leak</strong>  </p><br/><br/><p>You lose the piece of paper and cannot find the house. The house is still standing somewhere though, and when you later on want to construct a new house, you cannot reuse that spot.</p><br/><br/><pre><code>var<br/>    h: THouse;<br/>begin<br/>    h := THouse.Create('My house');<br/>    h := THouse.Create('My house'); // uh-oh, what happened to our first house?<br/>    ...<br/>    h.Free;<br/>    h := nil;<br/></code></pre><br/><br/><p>Here we overwrote the contents of the <code>h</code> variable with the address of a new house, but the old one is still standing... somewhere. After this code, there is no way to reach that house, and it will be left standing. In other words, the allocated memory will stay allocated until the application closes, at which point the operating system will tear it down.</p><br/><br/><p>Memory layout after first allocation:</p><br/><br/><pre><br/>    h<br/>    v<br/>---[ttttNNNNNNNNNN]---<br/>    1234My house<br/></pre><br/><br/><p>Memory layout after second allocation:</p><br/><br/><pre><br/>                       h<br/>                       v<br/>---[ttttNNNNNNNNNN]---[ttttNNNNNNNNNN]<br/>    1234My house       5678My house<br/></pre><br/><br/><p>A more common way to get this method is just to forget to free something, instead of overwriting it as above. In Delphi terms, this will occur with the following method:</p><br/><br/><pre><code>procedure OpenTheFrontDoorOfANewHouse;<br/>var<br/>    h: THouse;<br/>begin<br/>    h := THouse.Create('My house');<br/>    h.OpenFrontDoor;<br/>    // uh-oh, no .Free here, where does the address go?<br/>end;<br/></code></pre><br/><br/><p>After this method has executed, there's no place in our variables that the address to the house exists, but the house is still out there.</p><br/><br/><p>Memory layout:</p><br/><br/><pre><br/>    h                        &lt;--+<br/>    v                           +- before losing pointer<br/>---[ttttNNNNNNNNNN]---          |<br/>    1234My house             &lt;--+<br/><br/>    h (now points nowhere)   &lt;--+<br/>                                +- after losing pointer<br/>---[ttttNNNNNNNNNN]---          |<br/>    1234My house             &lt;--+<br/></pre><br/><br/><p>As you can see, the old data is left intact in memory, and will not<br/>be reused by the memory allocator. The allocator keeps track of which<br/>areas of memory has been used, and will not reuse them unless you<br/>free it.</p><br/><br/><hr><br/><br/><p><strong>Freeing the memory but keeping a (now invalid) reference</strong>  </p><br/><br/><p>Demolish the house, erase one of the pieces of paper but you also have another piece of paper with the old address on it, when you go to the address, you won't find a house, but you might find something that resembles the ruins of one.</p><br/><br/><p>Perhaps you will even find a house, but it is not the house you were originally given the address to, and thus any attempts to use it as though it belongs to you might fail horribly.</p><br/><br/><p>Sometimes you might even find that a neighbouring address has a rather big house set up on it that occupies three address (Main Street 1-3), and your address goes to the middle of the house. Any attempts to treat that part of the large 3-address house as a single small house might also fail horribly.</p><br/><br/><pre><code>var<br/>    h1, h2: THouse;<br/>begin<br/>    h1 := THouse.Create('My house');<br/>    h2 := h1; // copies the address, not the house<br/>    ...<br/>    h1.Free;<br/>    h1 := nil;<br/>    h2.OpenFrontDoor; // uh-oh, what happened to our house?<br/></code></pre><br/><br/><p>Here the house was torn down, through the reference in <code>h1</code>, and while <code>h1</code> was cleared as well, <code>h2</code> still has the old, out-of-date, address. Access to the house that is no longer standing might or might not work.</p><br/><br/><p>This is a variation of the dangling pointer above. See its memory layout.</p><br/><br/><hr><br/><br/><p><strong>Buffer overrun</strong>  </p><br/><br/><p>You move more stuff into the house than you can possibly fit, spilling into the neighbours house or yard. When the owner of that neighbouring house later on comes home, he'll find all sorts of things he'll consider his own.</p><br/><br/><p>This is the reason I chose a fixed-size array. To set the stage, assume that<br/>the second house we allocate will, for some reason, be placed before the<br/>first one in memory. In other words, the second house will have a lower<br/>address than the first one. Also, they're allocated right next to each other.</p><br/><br/><p>Thus, this code:</p><br/><br/><pre><code>var<br/>    h1, h2: THouse;<br/>begin<br/>    h1 := THouse.Create('My house');<br/>    h2 := THouse.Create('My other house somewhere');<br/>                         ^-----------------------^<br/>                          longer than 10 characters<br/>                         0123456789 &lt;-- 10 characters<br/></code></pre><br/><br/><p>Memory layout after first allocation:</p><br/><br/><pre><br/>                        h1<br/>                        v<br/>-----------------------[ttttNNNNNNNNNN]<br/>                        5678My house<br/></pre><br/><br/><p>Memory layout after second allocation:</p><br/><br/><pre><br/>    h2                  h1<br/>    v                   v<br/>---[ttttNNNNNNNNNN]----[ttttNNNNNNNNNN]<br/>    1234My other house somewhereouse<br/>                        ^---+--^<br/>                            |<br/>                            +- overwritten<br/></pre><br/><br/><p>The part that will most often cause crash is when you overwrite important parts<br/>of the data you stored that really should not be randomly changed. For instance<br/>it might not be a problem that parts of the name of the h1-house was changed,<br/>in terms of crashing the program, but overwriting the overhead of the<br/>object will most likely crash when you try to use the broken object,<br/>as will overwriting links that is stored to<br/>other objects in the object.</p><br/><br/><hr><br/><br/><p><strong>Linked lists</strong>  </p><br/><br/><p>When you follow an address on a piece of paper, you get to a house, and at that house there is another piece of paper with a new address on it, for the next house in the chain, and so on.</p><br/><br/><pre><code>var<br/>    h1, h2: THouse;<br/>begin<br/>    h1 := THouse.Create('Home');<br/>    h2 := THouse.Create('Cabin');<br/>    h1.NextHouse := h2;<br/></code></pre><br/><br/><p>Here we create a link from our home house to our cabin. We can follow the chain until a house has no <code>NextHouse</code> reference, which means it's the last one. To visit all our houses, we could use the following code:</p><br/><br/><pre><code>var<br/>    h1, h2: THouse;<br/>    h: THouse;<br/>begin<br/>    h1 := THouse.Create('Home');<br/>    h2 := THouse.Create('Cabin');<br/>    h1.NextHouse := h2;<br/>    ...<br/>    h := h1;<br/>    while h &lt;&gt; nil do<br/>    begin<br/>        h.LockAllDoors;<br/>        h.CloseAllWindows;<br/>        h := h.NextHouse;<br/>    end;<br/></code></pre><br/><br/><p>Memory layout (added NextHouse as a link in the object, noted with<br/>the four LLLL's in the below diagram):</p><br/><br/><pre><br/>    h1                      h2<br/>    v                       v<br/>---[ttttNNNNNNNNNNLLLL]----[ttttNNNNNNNNNNLLLL]<br/>    1234Home       +        5678Cabin      +<br/>                   |        ^              |<br/>                   +--------+              * (no link)<br/></pre><br/><br/><hr><br/><br/><p><strong>In basic terms, what is a memory address?</strong></p><br/><br/><p>A memory address is in basic terms just a number. If you think of memory<br/>as a big array of bytes, the very first byte has the address 0, the next one<br/>the address 1 and so on upwards. This is simplified, but good enough.</p><br/><br/><p>So this memory layout:</p><br/><br/><pre><br/>    h1                 h2<br/>    v                  v<br/>---[ttttNNNNNNNNNN]---[ttttNNNNNNNNNN]<br/>    1234My house       5678My house<br/></pre><br/><br/><p>Might have these two address (the leftmost - is address 0):</p><br/><br/><ul><br/><li>h1 = 4</li><br/><li>h2 = 23</li><br/></ul><br/><br/><p>Which means that our linked list above might actuall look like this:</p><br/><br/><pre><br/>    h1 (=4)                 h2 (=28)<br/>    v                       v<br/>---[ttttNNNNNNNNNNLLLL]----[ttttNNNNNNNNNNLLLL]<br/>    1234Home      0028      5678Cabin     0000<br/>                   |        ^              |<br/>                   +--------+              * (no link)<br/></pre><br/><br/><p>It is typical to store an address that "points nowhere" as a zero-address.</p><br/><br/><hr><br/><br/><p><strong>In basic terms, what is a pointer?</strong></p><br/><br/><p>A pointer is just a variable holding a memory address. You can typically ask the programming<br/>language to give you its number, but most programming languages and runtimes tries to<br/>hide the fact that there is a number beneath, just because the number itself does not<br/>really hold any meaning to you. It is best to think of a pointer as a black box, ie.<br/>you don't really know or care about how it is actually implemented, just as long as it<br/>works.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      LPHA BLEND SPRITE IN NINTENDO DS HOMEBREW
    </pattern>
    <template>
<![CDATA[<p>As a generic reference, i once wrote <a href="http://sylvainhb.blogspot.com/2006/09/alpha-blending.html" rel="nofollow">a small blog entry</a> about that issue. Basically, you first have to define which layer is alpha-blended against which other layer(s). Afaik,</p><br/><br/><ul><br/><li>the source layer(s) must be over destination layer(s) to have some blending displayed. that means the priority of source layers should be numerically lower than the the priority of destination layers.</li><br/><li>the source layer is what is going to be translucent, the destination(s) is what is going to be seen through (and yes, i find this rather confusing).</li><br/></ul><br/><br/><p>For the <a href="http://sylvainhb.blogspot.com/2011/09/oam-alpha.html" rel="nofollow">sprites, specifically</a>, you then have 3 ways to achieve alpha-blending depending on what you need and what you're "ready to pay" for it:</p><br/><br/><ul><br/><li>You can make all the sprites have some alpha-blending by turning on <code>BLEND_SRC_SPRITE</code> in <code>REG_BLDCNT[_SUB]</code> ... not that useful. </li><br/><li>You can selectively turn on blending of some sprites by using <code>ATTR0_TYPE_BLENDED</code>. The blending level will be the same for all sprites (and layers)</li><br/><li>bitmap-type sprites use direct colors (bypassing the palettes), so the <code>ATTR2_PALETTE()</code> field of GBA sprites is useless and has been recycled into <code>ATTR2_ALPHA</code>. </li><br/></ul><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      MOVE FROM C + + TO PYTHON ... OR ANOTH LANGUAG
    </pattern>
    <template>
<![CDATA[<blockquote><br/>  <p>I like the idea of not needing to compile the programs each time we make a change. I understand that the interpreted languages probably wont hit the same performance we currently get.</p><br/></blockquote><br/><br/><p>This is the biggest issue; can you live with the performance hit. You could try to use Python and <a href="http://www.python.org/doc/ext/intro.html" rel="nofollow" title="http://www.scribd.com/doc/2547864/msnetformattingstrings">extending it with your current C++ modules</a> for the performance heavy parts. Still, switching your entire system seems like a big effort if the only reason is the lack of C++ talent. Hiring people who know C++ seems like the cheaper option.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      PASS A FUNCTION AS A PARAMET IN C
    </pattern>
    <template>
<![CDATA[<p><strong>Declaration</strong></p><br/><br/><p>A prototype for a function which takes a function parameter looks like the following:</p><br/><br/><pre><code>void func ( void (*f)(int) );<br/></code></pre><br/><br/><p>This states that the parameter f will be a pointer to a function which has a void return type and which takes a single int parameter. The following function (print) is an example of a function which could be passed to func as a parameter because it is the proper type:</p><br/><br/><pre><code>void print ( int x ) {<br/>  cout &lt;&lt; x &lt;&lt; endl;<br/>}<br/></code></pre><br/><br/><p><strong>Function Call</strong></p><br/><br/><p>When calling a function with a function parameter, the value passed must be a pointer to a function. Use the function's name (without parens) for this:</p><br/><br/><pre><code>func(print);<br/></code></pre><br/><br/><p>would call func, passing the print function to it.</p><br/><br/><p><strong>Function Body</strong></p><br/><br/><p>As with any parameter, func can now use the parameter's name in the function body to access the value of the parameter. Let's say that func will apply the function it is passed to the numbers 0-4. Consider, first, what the loop would look like to call print directly:</p><br/><br/><pre><code>for ( int ctr = 0 ; ctr &lt; 5 ; ctr++ ) {<br/>  print(ctr);<br/>}<br/></code></pre><br/><br/><p>Since func's parameter declaration says that f is the name for a pointer to the desired function, we recall first that if f is a pointer then *f is the thing that f points to (i.e. the function print in this case). As a result, just replace every occurrence of print in the loop above with *f:</p><br/><br/><pre><code>void func ( void (*f)(int) ) {<br/>  for ( int ctr = 0 ; ctr &lt; 5 ; ctr++ ) {<br/>    (*f)(ctr);<br/>  }<br/>}<br/></code></pre><br/><br/><p>From <a href="http://math.hws.edu/bridgeman/courses/331/f05/handouts/c-c++-notes.html" rel="nofollow">http://math.hws.edu/bridgeman/courses/331/f05/handouts/c-c++-notes.html</a></p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      TOOL FOR MAKEFIL GENER
    </pattern>
    <template>
<![CDATA[<p>Other suggestions you may want to consider:</p><br/><br/><ul><br/><li><p><a href="http://www.scons.org/" rel="nofollow" title="Coding Guidelines for Cocoa">Scons</a> is a cross-platform, cross-compiler build library, uses Python scruipting for the build systems. Used in a variety of large projects, and performs very well.</p></li><br/><li><p>If you're using Qt, <a href="http://doc.trolltech.com/4.4/qmake-manual.html" rel="nofollow" title="Apple Developer Connection">QMake</a> is a nice build system too.</p></li><br/><li><p><a href="http://www.cmake.org/HTML/index.html" rel="nofollow">CMake</a> is also pretty sweet.</p></li><br/><li><p>Finally, <a href="http://www.google.co.uk/search?q=cross+platform+build+system" rel="nofollow">If all else fails...</a></p></li><br/></ul><br/><br/><p>Cheers,</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      UNIT TEST A CODE GENER
    </pattern>
    <template>
<![CDATA[<p>I started writing up a summary of my experience with my own code generator, then went back and re-read your question and found you had already touched upon the same issues yourself, focus on the execution results instead of the code layout/look.</p><br/><br/><p>Problem is, this is hard to test, the generated code might not be suited to actually run in the environment of the unit test system, and how do you encode the expected results?</p><br/><br/><p>I've found that you need to break down the code generator into smaller pieces and unit test those. Unit testing a full code generator is more like integration testing than unit testing if you ask me.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      C C + + PROGRAM HOW DOE THE SYSTEM ( WINDOW LINUX MAC OS X ) CALL THE MAIN ( ) FUNCTION
    </pattern>
    <template>
<![CDATA[<p>The .exe file (or equivalent on other platforms) contains an 'entry point' address.  To a first approximation, the OS loads the relevant sections of the .EXE file into ram, and then jumps to the entry point.</p><br/><br/><p>As others have said, this entry point will not be 'main', but will instead be a part of the runtime library - it will do things like initialising static objects, setting up the argc/argv parameters, setting up stdin/stdout/stderr, etc.   When it's done all that, it will call your main() function.  When main exits, the runtime goes through an analagous process of passing your return code back to the environment, calling static destructors, calling _atexit routines, etc.</p><br/><br/><p>If you have MS tools (perhaps not the freebie ones), then you have all the runtime source, and an easy way to look at it is to put a breakpoint on the closing brace of your main() method, and single step back up into the runtime.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      SEVER C C + + LIBRARI INTO ONE
    </pattern>
    <template>
<![CDATA[<p>On Unix like systems, the ld and ar utilities can do this. Check out <a href="http://en.wikipedia.org/wiki/Ar_(Unix)" rel="nofollow">http://en.wikipedia.org/wiki/Ar_(Unix)</a> or lookup the man pages on any linux box or through google, e.g 'unix man ar'.</p><br/><br/><p>Please note that you might be better off linking to a shared (dynamic) library. This would add a dependency to your executable but will dramatically reduce its size, especially if you're writing a graphic application.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      RANK AN ARRAY ( SORT ) BY VALU WITH A TWIST
    </pattern>
    <template>
<![CDATA[<p>Since you're using C++, I would do it something like this. The <code>SortIntPointers</code> function can be any sort algorithm, the important part is that it sorts the array of pointers based on the <code>int</code> that they are pointing to. Once that is done, you can go through the array of pointers and assign their sorted index which will end up in the original position in the original array.</p><br/><br/><pre><code>int* intArray; // set somewhere else<br/>int arrayLen;  // set somewhere else  <br/><br/>int** pintArray = new int*[arrayLen];<br/>for(int i = 0; i &lt; arrayLen; ++i)<br/>{<br/>    pintArray[i] = &amp;intArray[i];<br/>}<br/><br/>// This function sorts the pointers according to the values they<br/>// point to. In effect, it sorts intArray without losing the positional<br/>// information.<br/>SortIntPointers(pintArray, arrayLen);<br/><br/>// Dereference the pointers and assign their sorted position.<br/>for(int i = 0; i &lt; arrayLen; ++i)<br/>{<br/>    *pintArray[i] = i;<br/>}<br/></code></pre><br/><br/><p>Hopefully that's clear enough.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      C + + ERROR WITH CODE THAT HA MIN ( ) MAX ( ) CALL
    </pattern>
    <template>
<![CDATA[<p>Check if your code is including the <strong>windows.h</strong> header file and either your code or other third-party headers have their own <strong>min()</strong>/<strong>max()</strong> definitions. If yes, then prepend your <strong>windows.h</strong> inclusion with a definition of <strong>NOMINMAX</strong> like this:</p><br/><br/><pre><code>#define NOMINMAX<br/>#include &lt;windows.h&gt;<br/></code></pre><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      A DEBUG ONLI FUNCTION THAT TAKE A VARIABL ARGUMENT LIST LIKE PRINTF ( )
    </pattern>
    <template>
<![CDATA[<p>I still do it the old way, by defining a macro (XTRACE, below) which correlates to either a no-op or a function call with a variable argument list. Internally, call vsnprintf so you can keep the printf syntax:</p><br/><br/><pre><code>#include &lt;stdio.h&gt;<br/><br/>void XTrace0(LPCTSTR lpszText)<br/>{<br/>   ::OutputDebugString(lpszText);<br/>}<br/><br/>void XTrace(LPCTSTR lpszFormat, ...)<br/>{<br/>    va_list args;<br/>    va_start(args, lpszFormat);<br/>    int nBuf;<br/>    TCHAR szBuffer[512]; // get rid of this hard-coded buffer<br/>    nBuf = _vsntprintf(szBuffer, 511, lpszFormat, args);<br/>    ::OutputDebugString(szBuffer);<br/>    va_end(args);<br/>}<br/></code></pre><br/><br/><p>Then a typical #ifdef switch:</p><br/><br/><pre><code>#ifdef _DEBUG<br/>#define XTRACE XTrace<br/>#else<br/>#define XTRACE<br/>#endif<br/></code></pre><br/><br/><p>Well that can be cleaned up quite a bit but it's the basic idea.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      SORT AN ARRAY OF DOUBL POINTER BASE ON THE VALU THEY POINT TO
    </pattern>
    <template>
<![CDATA[<p>You're close. You're referencing the address of the array items when you swap, which isn't necessary. The items in the array are pointers, and that's what needs to be swapped.</p><br/><br/><p>See below:</p><br/><br/><pre><code>void SortArray( int ** pArray, int ArrayLength )<br/>{<br/>    int i, j, flag = 1;    // set flag to 1 to begin initial pass<br/>    int * temp;             // holding variable orig with no *<br/>    for(i = ArrayLength - 1; i &gt; 0 &amp;&amp; flag; i--)<br/>    {<br/>        flag = 0;<br/>        for (j = 0; j &lt; i; j++)<br/>        {<br/>            if (*pArray[j] &gt; *pArray[j+1])      // ascending order simply changes to &lt;<br/>            { <br/>                temp = pArray[j];             // swap elements<br/>                pArray[j] = pArray[j+1];<br/>                pArray[j+1] = temp;<br/>                flag = 1;               // indicates that a swap occurred.<br/>            }<br/>        }<br/>    }<br/>}<br/></code></pre><br/><br/><p>Also, check out <a href="http://rant.blackapache.net/2008/08/14/sorting-algorithms-the-bubble-sort/" rel="nofollow">this lovely blog post on Bubble Sorting</a> in case you're interested (sorry, shameless plug :)). Hope that helps you with your homework ;)</p><br/><br/><p><hr /></p><br/><br/><p>Edit: Note the subtle "optimisation" where you count back from the array length and only increment up until 'i' in the inner loop. This saves you from needlessly reparsing items that have already been sorted.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      PLACE A FILE IN RECYCL BIN INSTEAD OF DELET
    </pattern>
    <template>
<![CDATA[<p><a href="http://www.daveamenta.com/2008-05/c-delete-a-file-to-the-recycle-bin/" rel="nofollow">http://www.daveamenta.com/2008-05/c-delete-a-file-to-the-recycle-bin/</a></p><br/><br/><p>From above:</p><br/><br/><pre><code>using Microsoft.VisualBasic;<br/><br/>string path = @"c:\myfile.txt";<br/>FileIO.FileSystem.DeleteDirectory(path, <br/>    FileIO.UIOption.OnlyErrorDialogs, <br/>    RecycleOption.SendToRecycleBin);<br/></code></pre><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      C4341 XX SIGN VALU IS OUT OF RANG FOR ENUM CONSTANT
    </pattern>
    <template>
<![CDATA[<p>This is a <a href="http://forums.msdn.microsoft.com/en-US/vclanguage/thread/7bc77d72-c223-4d5e-b9f7-4c639c68b624/" rel="nofollow">compiler bug</a>.  Here's <a href="http://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=159519&amp;SiteID=1" rel="nofollow">another post</a> confirming it's a known issue. I've got the same issue in one of my projects and there's no way to prevent it from being triggered unless you have some way of avoiding the use of OdbcParameter. The most conservative way to suppress only the buggy warnings is to use</p><br/><br/><pre><code>#pragma warning( push )<br/>#pragma warning( disable: 4341 )<br/><br/>// code affected by bug<br/><br/>#pragma warning( pop )<br/></code></pre><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      MATCH LINUX DEVIC PATH TO WINDOW DRIVE NAME
    </pattern>
    <template>
<![CDATA[<p>Partitions have UUIDs associated with them. I don't know how to find these in Windows but in linux you can find the UUID for each partition with:</p><br/><br/><blockquote><br/>  <p>sudo vol_id -u device (e.g. /dev/sda1)</p><br/></blockquote><br/><br/><p>If there is an equivilent function in Windows you could simply store the UUIDs for whatever partition they pick then iterate through all known partitions in linux and match the UUIDs.</p><br/><br/><p><strong>Edit:</strong> This may be a linux-only thing, and it may speficially be the volid util that generates these from something (instead of reading off meta-data for the drive). Having said that, there is nothing stopping you getting the source for volid and checking out what it does.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      GO FROM JAVA C # TO C + +
    </pattern>
    <template>
<![CDATA[<p>Yeah, I got bit by the same bug.  The university tended to lean on Java, and then allowed you to choose the language you wanted to work with during projects.</p><br/><br/><p>The best way is to just jump in. Start small, take baby steps, and just Google things that confuse you when you get there. Also find projects that have released their source code. See how they structure their programs. Basically, just tinker with concepts.  There is plenty of information around the web.</p><br/><br/><p>Make it fun and grab a <a href="http://rads.stackoverflow.com/amzn/click/1598633600" rel="nofollow">C++ game development book</a> so it doesn't become mind numbing too quickly. </p><br/><br/><p>Here's some places that I found useful while learning</p><br/><br/><p><a href="http://www.cprogramming.com/" rel="nofollow"><a href="http://www.cprogramming.com/" rel="nofollow">http://www.cprogramming.com/</a></a></p><br/><br/><p><a href="http://www.wikipedia.com" rel="nofollow"><a href="http://www.wikipedia.com" rel="nofollow">http://www.wikipedia.com</a></a></p><br/><br/><p><a href="http://www.cplusplus.com/" rel="nofollow"><a href="http://www.cplusplus.com/" rel="nofollow">http://www.cplusplus.com/</a></a></p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      LOG WATCHER
    </pattern>
    <template>
<![CDATA[<p>You can use fseek() to clear the eof condition on the stream.  Essentially, read to the end of the file, sleep for a while, fseek() (without changing your position) to clear eof, the read to end of file again.  wash, rinse, repeat.  man fseek(3) for details.</p><br/><br/><p>Here's what it looks like in perl.  perl's seek() is essentially a wrapper for fseek(3), so the logic is the same:</p><br/><br/><pre><code>wembley 0 /home/jj33/swap &gt;#&gt; cat p<br/>my $f = shift;<br/>open(I, "&lt;$f") || die "Couldn't open $f: $!\n";<br/><br/>while (1) {<br/>  seek(I, 0, 1);<br/>  while (defined(my $l = &lt;I&gt;)) {<br/>    print "Got: $l";<br/>  }<br/>  print "Hit EOF, sleeping\n";<br/>  sleep(10);<br/>}<br/>wembley 0 /home/jj33/swap &gt;#&gt; cat tfile<br/>This is<br/>some<br/>text<br/>in<br/>a file<br/>wembley 0 /home/jj33/swap &gt;#&gt; perl p tfile<br/>Got: This is<br/>Got: some<br/>Got: text<br/>Got: in<br/>Got: a file<br/>Hit EOF, sleeping<br/></code></pre><br/><br/><p>Then, in another session:</p><br/><br/><pre><code>wembley 0 /home/jj33/swap &gt; echo "another line of text" &gt;&gt; tfile<br/></code></pre><br/><br/><p>And back to the original program output:</p><br/><br/><pre><code>Hit EOF, sleeping<br/>Got: another line of text<br/>Hit EOF, sleeping<br/></code></pre><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      MEMSET ( ) CAUS DATA ABORT
    </pattern>
    <template>
<![CDATA[<p><code>malloc</code> can return <code>NULL</code> if no memory is available. You're not checking for that.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      COMMUN WITH A MYSQL SERVER
    </pattern>
    <template>
<![CDATA[<p><a href="http://tangentsoft.net/mysql++/" rel="nofollow">MySQL++</a></p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      SUM DIMENS OF AN ARRAY SPECIFI AT RUN TIM
    </pattern>
    <template>
<![CDATA[<p>This could have applications. Lets say you implemented a 2D Conway's Game of Life (which defines a 2D plane, 1 for 'alive', 0 for 'dead') and you stored the Games history for every iteration (which then defines a 3D cube). If you wanted to know how many bacteria there was alive over history, you would use the above algorithm. You could use the same algorithm for a 3D, (and 4D, 5D etc.) version of Game of Life grid.</p><br/><br/><p>I'd say this was a question for recursion, I'm not yet a C programmer but I know it is possible in C. In python,</p><br/><br/><pre><code><br/>def iter_arr(array):<br/>  sum = 0<br/>  for i in array:<br/>    if type(i) == type(list()):<br/>      sum = sum + iter_arr(i)<br/>    else:<br/>      sum = sum + i<br/>  return sum <br/></code></pre><br/><br/><ol><br/><li>Iterate over each element in array</li><br/><li>If element is another array, call the function again</li><br/><li>If element is not array, add it to the sum</li><br/><li>Return sum</li><br/></ol><br/><br/><p>You would then apply this to each element in the 'cared about' dimension.</p><br/><br/><p>This is easier in python due to duck-typing though ...</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      IDE FOR LINUX
    </pattern>
    <template>
<![CDATA[<p>Actually, I recently made the switch from Visual Studio (<em>years</em> of experience there) to Linux and the first thing I did was try to find a reasonable IDE.</p><br/><br/><p>And then I noticed that this simply isn't how you work there*, and I threw everything out, spent a few days reading manuals, set up my shell (bash), set up a GVIM environment, learned the GCC/binutils toolchain, <code>make</code> and <code>gdb</code> and lived happily ever after.</p><br/><br/><p>There are certainly disadvantages but I am sure that I work much more productive since making the switch.</p><br/><br/><p>*) It <em>really</em> isn't! And that's not an anachronism either because the toolchain described above is incredibly mature and powerful. Any IDE has to replicate hundreds of unique features to get anywhere near the power of these tools that have been honed to the point of perfection for decades. The learning curve might be quite steep, but much less so than I expected.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      LINUX C C + + IDE FOR A LOW R SCREEN
    </pattern>
    <template>
<![CDATA[<p><a href="http://codeblocks.org/" rel="nofollow">Code::Blocks</a> is a highly configurable IDE. You can set up the various windows in any configuration, disable tool strips, etc. It is also, IMO, the C/C++ IDE for Linux with the best and most powerful modern features (debugging, code completion, code folding, <a href="http://www.codeblocks.org/features" rel="nofollow">etc</a>.)</p><br/><br/><p>You may be able to gain more usable screen space by changing the window manager theme.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      WITH STDBOOL.H C + +
    </pattern>
    <template>
<![CDATA[<p>I found the answer to my own question by finding a more compatible implementation of <code>stdbool.h</code> that is compliant with the C99 standard.</p><br/><br/><pre><code>#ifndef _STDBOOL_H<br/>#define _STDBOOL_H<br/><br/>#include  <br/><br/>/* C99 Boolean types for compilers without C99 support */<br/>/* http://www.opengroup.org/onlinepubs/009695399/basedefs/stdbool.h.html */<br/>#if !defined(__cplusplus)<br/><br/>#if !defined(__GNUC__)<br/>/* _Bool builtin type is included in GCC */<br/>/* ISO C Standard: 5.2.5 An object declared as <br/>type _Bool is large enough to store <br/>the values 0 and 1. */<br/>/* We choose 8 bit to match C++ */<br/>/* It must also promote to integer */<br/>typedef int8_t _Bool; <br/>#endif<br/><br/>/* ISO C Standard: 7.16 Boolean type */<br/>#define bool _Bool<br/>#define true 1<br/>#define false 0<br/>#define __bool_true_false_are_defined 1<br/><br/>#endif<br/><br/>#endif</code></pre><br/><br/><p>This is taken from the <a href="http://sourceforge.net/projects/adacl" rel="nofollow">Ada Class Library</a> project.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      FREE MEMORI LEAK DETECTOR FOR A C C + + PROGRAM AND IT PLUG IN DLL
    </pattern>
    <template>
<![CDATA[<p>I personally use <a href="http://vld.codeplex.com" rel="nofollow">Visual Leak Detector</a>, though it can cause large delays when large blocks are leaked (it displays the contents of the entire leaked block).</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      OVERLOAD FUNCTION IN C + + DLL DEF FILE
    </pattern>
    <template>
<![CDATA[<p>In the code itself, mark the functions you want to export using __declspec(dllexport). For example:</p><br/><br/><pre><code>#define DllExport __declspec(dllexport)<br/><br/>int DllExport  Foo( int a ) {<br/>  // implementation<br/>}<br/>int DllExport Foo( int a, int b ) {<br/>  // implementation<br/>}<br/></code></pre><br/><br/><p>If you do this, you do not need to list the functions in the .def file.</p><br/><br/><p>Alternatively, you may be able to use a default parameter value, like:</p><br/><br/><pre><code>int Foo( int a, int b = -1 )<br/></code></pre><br/><br/><p>This assumes that there exists a value for b that you can use to indicate that it is unused. If -1 is a legal value for b, or if there isn't or shouldn't be a default, this won't work.</p><br/><br/><p>Edit (Adam Haile):  Corrected to use __declspec as __dllspec was not correct so I could mark this as the official answer...it was close enough.  </p><br/><br/><p>Edit (Graeme): Oops - thanks for correcting my typo!</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      YOU RECOMMEND SOME GUID ABOUT EPOL ON LINUX
    </pattern>
    <template>
<![CDATA[<p>Here's an introduction to Epoll, a pretty basic tutorial: <a href="http://blog.kovyrin.net/2006/04/13/epoll-asynchronous-network-programming/" rel="nofollow">http://blog.kovyrin.net/2006/04/13/epoll-asynchronous-network-programming/</a></p><br/><br/><p>A more complete example can be found here: <a href="https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/" rel="nofollow">https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/</a></p><br/><br/><p>Also, the man pages: <a href="http://man-wiki.net/index.php/4%3aepoll" rel="nofollow">http://man-wiki.net/index.php/4:epoll</a></p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      OPEN A FILE IN NON EXCLUS MODE
    </pattern>
    <template>
<![CDATA[<blockquote><br/>  <p>Is there a way to open file in a non-exclusive way,</p><br/></blockquote><br/><br/><p>Yes, using Win32, passing the various FILE_SHARE_Xxxx flags to CreateFile.</p><br/><br/><blockquote><br/>  <p>is it cross platform?</p><br/></blockquote><br/><br/><p>No, it requires platform-specific code.</p><br/><br/><p>Due to annoying backwards compatibility concerns (DOS applications, being single-tasking, assume that nothing can delete a file out from under them, i.e. that they can fclose() and then fopen() without anything going amiss; Win16 preserved this assumption to make porting DOS applications easier, Win32 preserved this assumption to make porting Win16 applications easier, and it's awful), Windows defaults to opening files exclusively.</p><br/><br/><p>The underlying OS infrastructure supports deleting/renaming open files  (although I believe it does have the restriction that memory-mapped files cannot be deleted, which I think isn't a restriction found on *nix), but the default opening semantics do not.</p><br/><br/><p>C++ has no notion of any of this; the C++ operating environment is much the same as the DOS operating environment--no other applications running concurrently, so no need to control file sharing.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      MFC RESOURC LINK
    </pattern>
    <template>
<![CDATA[<ul><br/><li>For blogs: Your best bet would be the <a href="http://blogs.msdn.com/vcblog/default.aspx" rel="nofollow">Visual C++ Team Blog</a>.</li><br/><li>For books: <a href="http://rads.stackoverflow.com/amzn/click/1572316950" rel="nofollow">Programming Windows with MFC</a> is one of the best book on the subject.</li><br/><li>For tutorials: Simply <a href="http://www.google.ca/search?q=mfc+tutorial&amp;ie=utf-8&amp;oe=utf-8&amp;aq=t&amp;rls=org.mozilla:en-US:official&amp;client=firefox-a" rel="nofollow">search google for various tutorials on MFC</a>.</li><br/></ul><br/><br/><p><img src="http://ecx.images-amazon.com/images/I/711B8M7PXHL._SL500_BO2,204,203,200_PIsitb-dp-500-arrow,TopRight,45,-64_OU01_AA240_SH20_.gif" alt="alt text" /></p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      ON VISUAL STUDIO
    </pattern>
    <template>
<![CDATA[<p>Answering the purely subject question "recommend me a better C IDE and compiler" I find <a href="http://www.codeblocks.org/" rel="nofollow">Ming32w and Code::blocks (now with combined installer)</a> very useful on windows but YMMV as you are obviously used to the MS IDE and are just struggling with C.</p><br/><br/><p>May I suggest you concentrate on console applications to get a feel for the language first before you attempt to tie it together with a windows UI which in my experience is the hardest bit of windows development.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      GENER IN C # AND JAVA... AND TEMPLAT IN C + +
    </pattern>
    <template>
<![CDATA[<p>I'll add my voice to the noise and take a stab at making things clear:</p><br/><br/><h2>C# Generics allow you to declare something like this.</h2><br/><br/><pre><code>List&lt;Person&gt; foo = new List&lt;Person&gt;();<br/></code></pre><br/><br/><p>and then the compiler will prevent you from putting things that aren't <code>Person</code> into the list.<br><br/>Behind the scenes the C# compiler is just putting <code>List&lt;Person&gt;</code> into the .NET dll file, but at runtime the JIT compiler  goes and builds a new set of code, as if you had written a special list class just for containing people - something like <code>ListOfPerson</code>.</p><br/><br/><p>The benefit of this is that it makes it really fast. There's no casting or any other stuff, and because the dll contains the information that this is a List of <code>Person</code>, other code that looks at it later on using reflection can tell that it contains <code>Person</code> objects (so you get intellisense and so on).</p><br/><br/><p>The downside of this is that old C# 1.0 and 1.1 code (before they added generics) doesn't understand these new <code>List&lt;something&gt;</code>, so you have to manually convert things back to plain old <code>List</code> to interoperate with them. This is not that big of a problem, because C# 2.0 binary code is not backwards compatible. The only time this will ever happen is if you're upgrading some old C# 1.0/1.1 code to C# 2.0</p><br/><br/><h2>Java Generics allow you to declare something like this.</h2><br/><br/><pre><code>ArrayList&lt;Person&gt; foo = new ArrayList&lt;Person&gt;();<br/></code></pre><br/><br/><p>On the surface it looks the same, and it sort-of is. The compiler will also prevent you from putting things that aren't <code>Person</code> into the list.</p><br/><br/><p>The difference is what happens behind the scenes. Unlike C#, Java does not go and build a special <code>ListOfPerson</code> - it just uses the plain old <code>ArrayList</code> which has always been in Java. When you get things out of the array, the usual <code>Person p = (Person)foo.get(1);</code> casting-dance still has to be done. The compiler is saving you the key-presses, but the speed hit/casting is still incurred just like it always was.<br><br/>When people mention "Type Erasure" this is what they're talking about. The compiler inserts the casts for you, and then 'erases' the fact that it's meant to be a list of <code>Person</code> not just <code>Object</code></p><br/><br/><p>The benefit of this approach is that old code which doesn't understand generics doesn't have to care. It's still dealing with the same old <code>ArrayList</code> as it always has. This is more important in the java world because they wanted to support compiling code using Java 5 with generics, and having it run on old 1.4 or previous JVM's, which microsoft deliberately decided not to bother with.</p><br/><br/><p>The downside is the speed hit I mentioned previously, and also because there is no <code>ListOfPerson</code> pseudo-class or anything like that going into the .class files, code that looks at it later on (with reflection, or if you pull it out of another collection where it's been converted into <code>Object</code> or so on) can't tell in any way that it's meant to be a list containing only <code>Person</code> and not just any other array list.</p><br/><br/><h2>C++ Templates allow you to declare something like this</h2><br/><br/><pre><code>std::list&lt;Person&gt;* foo = new std::list&lt;Person&gt;();<br/></code></pre><br/><br/><p>It looks like C# and Java generics, and it will do what you think it should do, but behind the scenes different things are happening.</p><br/><br/><p>It has the most in common with C# generics in that it builds special <code>pseudo-classes</code> rather than just throwing the type information away like java does, but it's a whole different kettle of fish.</p><br/><br/><p>Both C# and Java produce output which is designed for virtual machines. If you write some code which has a <code>Person</code> class in it, in both cases some information about a <code>Person</code> class will go into the .dll or .class file, and the JVM/CLR will do stuff with this.</p><br/><br/><p>C++ produces raw x86 binary code. Everything is <em>not</em> an object, and there's no underlying virtual machine which needs to know about a <code>Person</code> class. There's no boxing or unboxing, and functions don't have to belong to classes, or indeed anything. </p><br/><br/><p>Because of this, the C++ compiler places no restrictions on what you can do with templates - basically any code you could write manually, you can get templates to write for you.<br><br/>The most obvious example is adding things:</p><br/><br/><p>In C# and Java, the generics system needs to know what methods are available for a class, and it needs to pass this down to the virtual machine. The only way to tell it this is by either hard-coding the actual class in, or using interfaces. For example:</p><br/><br/><pre><code>int addNames&lt;T&gt;( T first, T second ) { return first.Name() + second.Name(); }<br/></code></pre><br/><br/><p>That code won't compile in C# or Java, because it doesn't know that the type <code>T</code> actually provides a method called Name(). You have to tell it - in C# like this:</p><br/><br/><pre><code>interface IHasName{ string Name(); };<br/>int addNames&lt;T&gt;( T first, T second ) where T : IHasName { .... }<br/></code></pre><br/><br/><p>And then you have to make sure the things you pass to addNames implement the IHasName interface and so on. The java syntax is different (<code>&lt;T extends IHasName&gt;</code>), but it suffers from the same problems.</p><br/><br/><p>The 'classic' case for this problem is trying to write a function which does this</p><br/><br/><pre><code>int addNames&lt;T&gt;( T first, T second ) { return first + second; }<br/></code></pre><br/><br/><p>You can't actually write this code because there are no ways to declare an interface with the <code>+</code> method in it. You fail.</p><br/><br/><p>C++ suffers from none of these problems. The compiler doesn't care about passing types down to any VM's - if both your objects have a .Name() function, it will compile. If they don't, it won't. Simple.</p><br/><br/><p>So, there you have it :-)</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      LIST THE SYMBOL IN A .SO FILE
    </pattern>
    <template>
<![CDATA[<p>The standard tool for listing symbols is <code>nm</code>, you can use it simply like this:</p><br/><br/><pre><code>nm -g yourLib.so<br/></code></pre><br/><br/><p>If you want to see symbols of a C++ library, add the "-C" option which demangle the symbols (it's far more readable demangled).</p><br/><br/><pre><code>nm -gC yourLib.so<br/></code></pre><br/><br/><p>If your .so file is in elf format, you will have to use <code>readelf</code> program to extract symbol information from the binary. </p><br/><br/><pre><code>readelf -Ws /usr/lib/libexample.so<br/></code></pre><br/><br/><p>You only should extract those that are defined in this .so file, not in the libraries referenced by it. Seventh column should contain a number in this case. You can extract the corresponding lines with <code>awk</code>:</p><br/><br/><pre><code>readelf -Ws /usr/lib/libstdc++.so.6 | awk '{print $8}';<br/></code></pre><br/><br/><p>Update: Thanks to Pavel Shved and Gaspin, I've updated the answer</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      WHAT IS THE BEST WAY TO ESTIM THE CODE STATIC DATA SIZE OF PROGRAM
    </pattern>
    <template>
<![CDATA[<p>"size" is the traditional tool.  "readelf" has a lot of options.</p><br/><br/><pre><code>$ size /bin/sh<br/>   text    data     bss     dec     hex filename<br/> 712739   37524   21832  772095   bc7ff /bin/sh<br/></code></pre><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      GUI DEVELOP
    </pattern>
    <template>
<![CDATA[<p>Your best bet may be to port it to a cross-platform widget library such as <a href="http://en.wikipedia.org/wiki/WxWidgets" rel="nofollow">wxWidgets</a>, which would give you portability to any platform wxWidgets supports.</p><br/><br/><p>It's also important to make the distinction between Gnome libraries and GTK, and likewise KDE libraries and Qt. If you write the code to use GTK or Qt, it should work fine for users of any desktop environment, including less popular ones like XFCE. If you use other Gnome or KDE-specific libraries to do non-widget-related tasks, your app would be less portable between desktop environments.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      GENER TYPE IN C + + AND JAVA
    </pattern>
    <template>
<![CDATA[<p>There is a big difference between them. In C++ you don't have to specify a class or an interface for the generic type. That's why you can create truly generic functions and classes, with the caveat of a looser typing.</p><br/><br/><pre><code>&lt;typename T&gt; T sum(T a, T b) { return a + b; }<br/></code></pre><br/><br/><p>The method above adds two objects of the same type, and can be used for any type T that has the "+" operator available.</p><br/><br/><p>In Java you have to specify a type if you want to call methods on the objects passed, something like:</p><br/><br/><pre><code>&lt;T extends Something&gt; T sum(T a, T b) { return a.add ( b ); }<br/></code></pre><br/><br/><p>In C++ generic functions/classes can only be defined in headers, since the compiler generates different functions for different types (that it's invoked with). So the compilation is slower. In Java the compilation doesn't have a major penalty, but Java uses a technique called "erasure" where the generic type is erased at runtime, so at runtime Java is actually calling ...</p><br/><br/><pre><code>Something sum(Something a, Something b) { return a.add ( b ); }<br/></code></pre><br/><br/><p>So generic programming in Java is not really useful, it's only a little syntactic sugar to help with the new foreach construct.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      VIRTUAL FUNCTION IN CONSTRUCTOR WHI DO LANGUAG DIFFER
    </pattern>
    <template>
<![CDATA[<p>There's a fundamental difference in how the languages define an object's life time. In Java and .Net the object members are zero/null initialized before any constructor is run and is at this point that the object life time begins. So when you enter the constructor you've already got an initialized object.</p><br/><br/><p>In C++ the object life time only begins when the constructor finishes (although member variables and base classes are fully constructed before it starts). This explains the behaviour when virtual functions are called and also why the destructor isn't run if there's an exception in the constructor's body.</p><br/><br/><p>The problem with the Java/.Net definition of object lifetime is that it's harder to make sure the object always meets its invariant without having to put in special cases for when the object is initialized but the constructor hasn't run. The problem with the C++ definition is that you have this odd period where the object is in limbo and not fully constructed.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      MYSQL CONNECTOR FOR C + + OR C
    </pattern>
    <template>
<![CDATA[<p><a href="http://jan.kneschke.de/2008/9/9/async-mysql-queries-with-c-api" rel="nofollow">http://jan.kneschke.de/2008/9/9/async-mysql-queries-with-c-api</a><br/><a href="http://forums.mysql.com/read.php?45,183339,183339" rel="nofollow">http://forums.mysql.com/read.php?45,183339,183339</a><br/>enjoy</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      DLL FUNCTION FROM VB6
    </pattern>
    <template>
<![CDATA[<p>By using <code>__declspec</code> for export, the function name will get exported <em>mangled</em>, i.e. contain type information to help the C++ compiler resolve overloads.</p><br/><br/><p>VB6 cannot handle mangled names. As a workaround, you have to de-mangle the names. The easiest solution is to link the DLL file using an <a href="http://msdn.microsoft.com/en-us/library/d91k01sh%28VS.80%29.aspx" rel="nofollow">export definition</a> file in VC++. The export definition file is very simple and just contains the name of the DLL and a list of exported functions:</p><br/><br/><pre><code>LIBRARY mylibname<br/>EXPORTS<br/>    myfirstfunction<br/>    secondfunction<br/></code></pre><br/><br/><p>Additionally, you have to specify the <code>stdcall</code> calling convention because that's the only calling convention VB6 can handle. There's a project using assembly injection to handle C calls but I guess you don't want to use this difficult and error-prone method.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      INTELLISENS TO RELIABL WORK IN VISUAL STUDIO 2008
    </pattern>
    <template>
<![CDATA[<p>I've also realized than Intellisense is sometime 'lost', on some big project. Why? No idea.</p><br/><br/><p>This is why we have bought <a href="http://www.wholetomato.com/" rel="nofollow">Visual Assist</a> (from <a href="http://www.wholetomato.com/" rel="nofollow">Tomato software</a>) and disabled Intellisense by deleting the dll feacp.dll in the Visual studio subdirectory (C:\Program Files\Microsoft Visual Studio 8\VC\vcpackages)</p><br/><br/><p>This is not a solution, just a workaround.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      WRAP A FUNCTION WITH VARIABL LENGTH ARGUMENT
    </pattern>
    <template>
<![CDATA[<p>the problem is that you cannot use 'printf' with va_args.  You must use vprintf if you are using variable argument lists.  vprint, vsprintf, vfprintf, etc.  (there are also 'safe' versions in Microsoft's C runtime that will prevent buffer overruns, etc.)</p><br/><br/><p>You sample works as follows:</p><br/><br/><pre><code>void myprintf(char* fmt, ...)<br/>{<br/>    va_list args;<br/>    va_start(args,fmt);<br/>    vprintf(fmt,args);<br/>    va_end(args);<br/>}<br/><br/>int _tmain(int argc, _TCHAR* argv[])<br/>{<br/>    int a = 9;<br/>    int b = 10;<br/>    char v = 'C'; <br/>    myprintf("This is a number: %d and \nthis is a character: %c and \n another number: %d\n",a, v, b);<br/>    return 0;<br/>}<br/></code></pre><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      THE CORRECT VERSION FOR A COM DLL REFERENC IN A .NET PROJECT
    </pattern>
    <template>
<![CDATA[<p>The Guid refers to the Guid for the TypeLib not the DLL directly.  The version numbers refer to the TypeLib's version not the DLLs.  </p><br/><br/><p>The version number will come from your idl file, and I believe it only supports a major and minor version and not a build version. Is this version changing when you modify the typelib?</p><br/><br/><p>The version numbers will appear in the registry under:<br/>HKEY_CLASSES_ROOT\Typelib{typelib uuid}\Major.Minor</p><br/><br/><p>If the minor version is set to 0 then I believe it will import the 'latest' version that matches the major version, but the major version must be set to something.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      TRACK # INCLUD DEPEND
    </pattern>
    <template>
<![CDATA[<p>If you have access to GCC/G++, then the <a href="http://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html#Preprocessor-Options" rel="nofollow"><code>-M</code> option</a> will output the dependency list.  It doesn't do any of the extra stuff that the other tools do, but since it is coming from the compiler, there is no chance that it will pick up files from the "wrong" place.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      N INTPTR TO A STREAM
    </pattern>
    <template>
<![CDATA[<p>You can avoid the copy if you use an <a href="http://msdn.microsoft.com/en-us/library/system.io.unmanagedmemorystream.aspx">UnmanagedMemoryStream()</a> instead (class exists in .NET FCL 2.0 and later). Like MemoryStream, it is a subclass of IO.Stream, and has all the usual stream operations.</p><br/><br/><p>Microsoft's description of the class is:</p><br/><br/><blockquote><br/>  <p>Provides access to unmanaged blocks of memory from managed code.</p><br/></blockquote><br/><br/><p>...which pretty much tells you what you need to know. Note that UnmanagedMemoryStream() is not CLS-compliant.</p><br/>]]>    </template>
  </category>
  <category>
    <pattern>
      SCP A FILE PROGRAMAT USE C
    </pattern>
    <template>
<![CDATA[<p><a href="http://www.libssh2.org/wiki/index.php/Main_Page" rel="nofollow">libssh2</a>, perhaps?  I have used the perl binding successfully to scp/sftp files, so I'm assuming it is not much harder to do the same with the core c API.</p><br/>]]>    </template>
  </category>
</aiml>
